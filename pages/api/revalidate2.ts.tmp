import type { NextApiRequest, NextApiResponse } from 'next';
import { revalidatePath, revalidateTag } from 'next/cache';

type ResponseData = {
  success: boolean;
  results?: any[];
  summary?: {
    total: number;
    succeeded: number;
    failed: number;
    duration: string;
  };
  error?: string;
  timestamp: string;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  const startTime = Date.now();

  // Only allow GET requests
  if (req.method !== 'GET') {
    console.log('[Revalidate API] ‚ùå Method not allowed:', req.method);
    return res.status(405).json({
      success: false,
      error: 'Method not allowed. Use GET',
      timestamp: new Date().toISOString()
    });
  }

  try {
    // Get parameters from query string
    const { path, tag, tags: tagsParam, type = 'page' } = req.query;

    // Parse tags from comma-separated string
    const tags = typeof tagsParam === 'string'
      ? tagsParam.split(',').map(t => t.trim()).filter(Boolean)
      : [];

    // Validate input
    if (!path && !tag && tags.length === 0) {
      console.log('[Revalidate API] ‚ùå Error: Missing required parameters');
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters. Provide "path" or "tag" or "tags"',
        timestamp: new Date().toISOString()
      });
    }

    const results: any[] = [];

    // Revalidate by path
    if (path && typeof path === 'string') {
      try {
        // type can be 'page' or 'layout'
        const pathType = (type === 'layout' ? 'layout' : 'page') as 'page' | 'layout';
        revalidatePath(path, pathType);

        const result = {
          type: 'path',
          path,
          pathType,
          status: 'success',
          timestamp: new Date().toISOString(),
          duration: `${Date.now() - startTime}ms`
        };

        results.push(result);
        console.log(`[Revalidate API] ‚úÖ Path revalidated: ${path} (${pathType})`, result);
      } catch (error: any) {
        const result = {
          type: 'path',
          path,
          pathType: type,
          status: 'error',
          error: error.message,
          timestamp: new Date().toISOString(),
          duration: `${Date.now() - startTime}ms`
        };

        results.push(result);
        console.log(`[Revalidate API] ‚ùå Path revalidation failed: ${path}`, result);
      }
    }

    // Revalidate by tag(s)
    const tagsToRevalidate = tag && typeof tag === 'string' ? [tag, ...tags] : tags;

    for (const tagName of tagsToRevalidate) {
      try {
        revalidateTag(tagName);

        const result = {
          type: 'tag',
          tag: tagName,
          status: 'success',
          timestamp: new Date().toISOString(),
          duration: `${Date.now() - startTime}ms`
        };

        results.push(result);
        console.log(`[Revalidate API] ‚úÖ Tag revalidated: ${tagName}`, result);
      } catch (error: any) {
        const result = {
          type: 'tag',
          tag: tagName,
          status: 'error',
          error: error.message,
          timestamp: new Date().toISOString(),
          duration: `${Date.now() - startTime}ms`
        };

        results.push(result);
        console.log(`[Revalidate API] ‚ùå Tag revalidation failed: ${tagName}`, result);
      }
    }

    // Summary logging
    const successCount = results.filter(r => r.status === 'success').length;
    const errorCount = results.filter(r => r.status === 'error').length;

    console.log(`[Revalidate API] üìä Summary: ${successCount} succeeded, ${errorCount} failed (${Date.now() - startTime}ms)`);

    return res.status(200).json({
      success: errorCount === 0,
      results,
      summary: {
        total: results.length,
        succeeded: successCount,
        failed: errorCount,
        duration: `${Date.now() - startTime}ms`
      },
      timestamp: new Date().toISOString()
    });

  } catch (error: any) {
    console.log('[Revalidate API] ‚ùå Unexpected error:', error.message);
    return res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
}
